--- !ruby/object:RI::MethodDescription 
aliases: []

block_params: 
comment: 
- !ruby/struct:SM::Flow::P 
  body: "@overload stub_chain(method1, method2) @overload stub_chain(&quot;method1.method2&quot;) @overload stub_chain(method1, method_to_value_hash)"
- !ruby/struct:SM::Flow::P 
  body: Stubs a chain of methods.
- !ruby/struct:SM::Flow::P 
  body: "## Warning:"
- !ruby/struct:SM::Flow::P 
  body: Chains can be arbitrarily long, which makes it quite painless to violate the Law of Demeter in violent ways, so you should consider any use of `stub_chain` a code smell. Even though not all code smells indicate real problems (think fluent interfaces), `stub_chain` still results in brittle examples. For example, if you write `foo.stub_chain(:bar, :baz =&gt; 37)` in a spec and then the implementation calls `foo.baz.bar`, the stub will not work.
- !ruby/struct:SM::Flow::P 
  body: "@example"
- !ruby/struct:SM::Flow::VERB 
  body: "    double.stub_chain(&quot;foo.bar&quot;) { :baz }\n    double.stub_chain(:foo, :bar =&gt; :baz)\n    double.stub_chain(:foo, :bar) { :baz }\n\n    # Given any of ^^ these three forms ^^:\n    double.foo.bar # =&gt; :baz\n\n    # Common use in Rails/ActiveRecord:\n    Article.stub_chain(&quot;recent.published&quot;) { [Article.new] }\n"
full_name: RSpec::Mocks::Methods#stub_chain
is_singleton: false
name: stub_chain
params: (*chain, &blk)
visibility: public
